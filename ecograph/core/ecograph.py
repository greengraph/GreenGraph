# %%

import numpy as np
import pandas as pd
import xarray as xr
import networkx as nx
from datetime import datetime
from typing import Any, Literal
import uuid

class CustomMultiDiGraph(nx.MultiDiGraph):
    r"""
    A custom directed graph class that extends [`networkx.MultiDiGraph`](https://networkx.org/documentation/stable/reference/classes/multidigraph.html).
    

    !!! note "Mathematical Definition"

        A MultiDiGraph is a [**di**rected **graph**](https://en.wikipedia.org/wiki/Directed_graph) that allows **multi**ple edges between nodes:

        ``` mermaid
        graph TD
        1((1)) -->|"(1,2)"₁| 2((2))
        1 -->|"(1,2)₂"| 2
        2 -->|"(2,3)"| 3((3))
        3 -->|"(3,1)"| 1
        ```

    [All NetworkX methods](https://networkx.org/documentation/stable/reference/index.html) of the MultiDiGraph class are available.
    Only the [`add_node`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_node.html#networkx.MultiDiGraph.add_node)
    and [`add_edge`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_edge.html#networkx.MultiDiGraph.add_edge)
    methods have been customized to ensure nodes and edges have consistent attributes:

    # Node Attributes

    | Attribute   | Type   | Description                                                    | Req.? | Possible Values             | 
    |-------------|--------|----------------------------------------------------------------|-------|-----------------------------|
    | uuid        | str    | Unique [random identifier (UUID v4)]((https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random))) | ✅ | Autogenerated |
    | name        | str    | Name of the node (e.g., `electricity production`)              | ✅    | None, can be any string     |
    | product     | str    | Product associated with the node (e.g., 'electricity')         | ✅    | None, can be any string     |
    | amount      | float  | Amount associated with the node (e.g., 1000)                   | ✅    | None, can be any float      |
    | location    | str    | Location of the node (e.g., 'USA')                             | ❌    | None, can be any string     |
    | type        | str    | Type of the node (e.g., `process`, `sector`)                   | ❌    | None, can be any string     |
    | unit        | str    | Unit of the amount (e.g., `GWh`)                               | ❌    | None, can be any string     |
    | loops       | bool   | Whether the node has loops (default: False)                    | ❌    | True, False                 |
    | edges       | bool   | Whether the node has edges (default: False)                    | ❌    | True, False                 |
    | database    | str    | Database associated with the node (e.g., 'Ecoinvent')          | ❌    | None, can be any string     |
    | databasecode| str    | XXXXXXXXXXXXXXXXXXXXXXXXXXX                                    | ❌    | None, can be any string     |
    | metadata    | dict   | Additional metadata for the node (default: empty dict)         | ❌    | None, can be any dictionary |

    # Edge Attributes

    | Attribute   | Type   | Description                                                    | Req.? | Possible Values             |
    |-------------|--------|----------------------------------------------------------------|-------|-----------------------------|
    | uuid        | str    | Unique [random identifier (UUID v4)]((https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random))) | ✅ | Autogenerated |
    | name        | str    | Name of the edge (e.g., `electricity`)              | ❌    | None, can be any string     |
    | weight      | float  | Weight of the edge (e.g., `1000`)                   | ✅    | None, can be any float      |
    | unit        | str    | Unit of the weight (e.g., `GWh`)                               | ❌    | None, can be any string     |
    | databasecode| str    | XXXXXXXXXXXXXXXXXXXXXXXXXXX                                    | ❌    | None, can be any string     |
    | metadata    | dict   | Additional metadata for the edge (default: empty dict)         | ❌    | None, can be any dictionary |

    !!! Terminology

        - `flow` is used in the meaning of Diestel (2025), describing a numerical value assigned to an edge. This can describe a flow of material, energy or money.
           However, it can also describe the relation (=concordance) between two nodes.
        
           
    # Matrix/Graph Conventions

    ## `loop` Parameter

    There are two different conventions in 

    If `loops=True`, the elements $a_{ii}$ of the adjacency matrix (eg. technosphere matrix) describe a flow from node $i$ to itself, which indicates _self-consumption_.  
    If `loops=False`, the elements $a_{ij}$ of the adjacency matrix (eg. technical coefficient matrix) indicate the production of the output of node $i$.

    $$
    \mathbf{I} - \mathbf{A}
    $$

    and

    $$
    \mathbf{A}
    $$

    ## `edges` Parameter

    Input-output tables are generally very dense. This means that most of the elements in the adjacency matrix are non-zero.
    A table of ~10'000 sectors can therefore have ~300'000 edges.
    Storing all edges of such a system in a graph can therefore require a lot of memory.

    The `edges` parameter allows to retain edges in the matrix, without the need to add it to the graph.

    See Also
    --------
    [`networkx.MultiDiGraph`](https://networkx.org/documentation/stable/reference/classes/multidigraph.html)

    References
    ----------
    - Heijungs, Reinout, Yi Yang, and Hung-Suck Park.  
    "A or I-A? Unifying the computational structures of process-and IO-based LCA for clarity and consistency."  
    _Journal of Industrial Ecology_
    26.5 (2022): 1824-1836.
    doi:[10.1111/jiec.13323](https://doi.org/10.1111/jiec.13323)
    - Diestel, Reinhard.
    _Graph Theory (6th Edition)_.  Springer, 2025.
    doi:[10.1007/978-3-662-70107-2](https://doi.org/10.1007/978-3-662-70107-2)

    """
    def add_node(
        self,
        name: str,
        product: str,
        amount: float,
        unit: str = None,
        location: str = None,
        type: str = None,
        loops: bool = False,
        system: str = None,
        metadata: dict = None,
    ) -> None:
        """Adds a node with custom attributes to the graph."""
        node_data = {
            'name': name,
            'product': product,
            'amount': amount,
            'unit': unit,
            'location': location,
            'type': type,
            'loops': loops,
            'edges': False,
            'system': system,
            'metadata': metadata or {}
        }
        super().add_node(
            node_for_adding=str(uuid.uuid4()),
            **node_data
        )

    def add_edge(
        self,
        source: str,
        target: str,
        key: str,
        amount: float,
        name: str = None,
        unit: str = None,
        metadata: dict = None
    ) -> None:
        """Adds an edge with custom attributes to the graph."""
        edge_data = {
            'amount': amount,
            'name': name,
            'unit': unit,
            'metadata': metadata or {}
        }
        if self.graph.node[target]['edges_as_matrix'] == True:
            raise AttributeError(f"No edges to node {target} can be added. This is because it has no edges stored on the graph. Instead, edges are stored in a matrix.")
        super().add_edge(
            u_for_edge=source,
            v_for_edge=target,
            key=key,
            **edge_data
        )

    def remove_node(
        self,
        uuid: str = None,
        conditions: dict = None
    ) -> None:
        """
        Given a node (=UUID string) or a dictionary of node attributes, removes the node from the graph.

        Notes
        -----
        Nested attributes (such as attributes stored in the `metadata` dictionary)
        can be accessed by prefixing the key with `metadata.`:
        ```
        conditions = {
            'product': 'electricity',
            'location': 'USA',
            'metadata.database': 'ecoinvent'
        }
        ```

        See Also
        --------
        [`networkx.MultiDiGraph.remove_node`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.remove_node.html#networkx.MultiDiGraph.remove_node)

        Warnings
        --------
        If the node has edges stored in a matrix, it cannot be removed from the graph.
        In this case, the entire system must be removed using the [][`remove_system`] method.

        Parameters
        ----------
        uuid: str
            The UUID of the node to remove.
        conditions: dict
            A dictionary of node attributes to match.  
            `keys` are node attributes, `values` are expected values.

        Raises
        ------
        AttributeError
            If no nodes are found that match the condition.
        AttributeError
            If multiple nodes are found that match the condition.
        AttributeError
            If the node has edges stored in a matrix and can therefore not be deleted individually.
        """
        if (uuid is None and conditions is None) or (uuid is not None and conditions is not None):
            raise AttributeError("EITHER a node (=UUID string) or conditions dictionary must be provided.")
        if uuid is not None:
            if self.graph.has_node(uuid) == False:
                raise AttributeError(f"The node {uuid} does not exist in the graph.")
            else:
                pass
        elif conditions is not None:
            uuid = self.get_node_by_attributes(conditions)        
        if self.graph[uuid]['edges_as_matrix'] == True:
            raise AttributeError(f"The individual node {node} cannot be removed no edges stored on the graph. This is because its edges are stored in a matrix.")
        else:
            self.graph.remove_node(uuid)

    def remove_system(
        self,
        system: str
    ) -> None:
        """
        Given a system name (=node attribute `system`), removes all nodes of the system from the graph.
        
        Parameters
        ----------
        system: str
            The name of the system to remove.
        
        Raises
        ------
        AttributeError
            If no nodes are found that match the condition.        
        """
        list_of_nodes = [node for node, attrs in self.graph.nodes(data=True) if attrs['system'] == system]
        if len(list_of_nodes) == 0:
            raise AttributeError(f"No nodes found with the given system name.")
        self.graph.remove_nodes_from(list_of_nodes)


    def get_node_by_attributes(
        self,
        conditions: dict
    ) -> str:
        """
        Given a dictionary of node attributes, returns the node (=UUID string) that matches all conditions.

        Notes
        -----
        Nested attributes (such as attributes stored in the `metadata` dictionary)
        can be accessed by prefixing the key with `metadata.`:
        ```
        conditions = {
            'product': 'electricity',
            'location': 'USA',
            'metadata.database': 'ecoinvent'
        }
        ```

        Parameters
        ----------
        conditions: dict
            A dictionary of node attributes to match.  
            `keys` are node attributes, `values` are expected values.

        Raises
        ------
        AttributeError
            If no nodes are found that match the condition.
        AttributeError
            If multiple nodes are found that match the condition.

        Returns
        -------
        str
            The node (=UUID string) that matches the conditions.
        """

        def _condition_met(node: dict):
            for key_expected, value_expected in conditions.items():
                if key_expected.startswith('metadata.'):
                    subkey_expected = key_expected.split('.', 1)[1]
                    if 'metadata' not in node or subkey_expected not in node['metadata']:
                        return False
                    value_actual = node['metadata'][subkey_expected]
                else:
                    if key_expected not in node:
                        return False
                    else:
                        value_actual = node[key_expected]
                
                if value_actual != value_expected:
                    return False
                else:
                    return True

        list_of_nodes = [(node, data) for node, data in self.nodes(data=True) if _condition_met(node)]

        if len(list_of_nodes) == 0:
            raise AttributeError(f"No nodes found with the given attributes.")
        elif len(list_of_nodes) > 1:
            raise AttributeError(f"Multiple nodes found with the given attributes. Please refine your attributes.")
        else:
            return list_of_nodes[0][0]


class ecograph():
    def __init__(self):
        self.graph = CustomMultiDiGraph()
        self.matrices = {}
        self.metadata = {
            'created': datetime.now(),
            'comment': None,
        }

    def random(self):
        """
        Returns a view of a random node from the graph.

        See Also
        --------
        [`networkx.utils.arbitrary_element`](https://networkx.org/documentation/stable/reference/generated/networkx.utils.misc.arbitrary_element.html#networkx.utils.misc.arbitrary_element)

        Returns
        -------
        [`networkx.classes.reportviews.NodeDataView`](https://github.com/networkx/networkx/blob/e3542acf18c53d07f80a5b4c17d50218d7259469/networkx/classes/reportviews.py#L287)
        """
        return self.graph.nodes(nx.utils.arbitrary_element(self.graph.nodes()))
    
    def compute_production_vector(
        self,
        node: str,
    ) -> np.ndarray:
        
        vector_final_demand = np.zeros(self.graph.number_of_nodes())

# %%
