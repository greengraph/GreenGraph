# %%

import numpy as np
import pandas as pd
import xarray as xr
import networkx as nx
from datetime import datetime
import uuid
from operator import itemgetter


from greengraph.math.matrix import (
    calculate_production_vector,
    calculate_inventory_vector,
    calculate_impact_vector
)


class GreenGraphMultiDiGraph(nx.MultiDiGraph):
    r"""
    A custom directed graph class that extends [`networkx.MultiDiGraph`](https://networkx.org/documentation/stable/reference/classes/multidigraph.html).
    

    !!! note "Mathematical Definition"

        A MultiDiGraph is a [**di**rected **graph**](https://en.wikipedia.org/wiki/Directed_graph) that allows **multi**ple edges between nodes:

        ``` mermaid
        graph TD
        1((1)) -->|"(1,2)"₁| 2((2))
        1 -->|"(1,2)₂"| 2
        2 -->|"(2,3)"| 3((3))
        3 -->|"(3,1)"| 1
        ```

    [All NetworkX methods](https://networkx.org/documentation/stable/reference/index.html) of the MultiDiGraph class are available.
    Only the [`add_node`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_node.html#networkx.MultiDiGraph.add_node)
    and [`add_edge`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_edge.html#networkx.MultiDiGraph.add_edge)
    methods have been customized to ensure nodes and edges have consistent attributes:

    # Node Attributes

    | Attribute   | Type   | Description                                                    | Req.? | Possible Values             | 
    |-------------|--------|----------------------------------------------------------------|-------|-----------------------------|
    | uuid        | str    | Unique [random identifier (UUID v4)]((https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random))) | ✅ | Autogenerated |
    | name        | str    | Name of the node (e.g., `electricity production`)              | ✅    | None, can be any string     |
    | product     | str    | Product associated with the node (e.g., 'electricity')         | ✅    | None, can be any string     |
    | amount      | float  | Amount associated with the node (e.g., 1000)                   | ✅    | None, can be any float      |
    | location    | str    | Location of the node (e.g., 'USA')                             | ❌    | None, can be any string     |
    | type        | str    | Type of the node (e.g., `process`, `sector`)                   | ❌    | None, can be any string     |
    | unit        | str    | Unit of the amount (e.g., `GWh`)                               | ❌    | None, can be any string     |
    | loops       | bool   | Whether the node has loops (default: False)                    | ❌    | True, False                 |
    | edges       | bool   | Whether the node has edges (default: False)                    | ❌    | True, False                 |
    | database    | str    | Database associated with the node (e.g., 'Ecoinvent')          | ❌    | None, can be any string     |
    | databasecode| str    | XXXXXXXXXXXXXXXXXXXXXXXXXXX                                    | ❌    | None, can be any string     |
    | metadata    | dict   | Additional metadata for the node (default: empty dict)         | ❌    | None, can be any dictionary |

    # Edge Attributes

    | Attribute   | Type   | Description                                                    | Req.? | Possible Values             |
    |-------------|--------|----------------------------------------------------------------|-------|-----------------------------|
    | uuid        | str    | Unique [random identifier (UUID v4)]((https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random))) | ✅ | Autogenerated |
    | name        | str    | Name of the edge (e.g., `electricity`)              | ❌    | None, can be any string     |
    | weight      | float  | Weight of the edge (e.g., `1000`)                   | ✅    | None, can be any float      |
    | unit        | str    | Unit of the weight (e.g., `GWh`)                               | ❌    | None, can be any string     |
    | databasecode| str    | XXXXXXXXXXXXXXXXXXXXXXXXXXX                                    | ❌    | None, can be any string     |
    | metadata    | dict   | Additional metadata for the edge (default: empty dict)         | ❌    | None, can be any dictionary |

    !!! Terminology

        - `flow` is used in the meaning of Diestel (2025), describing a numerical value assigned to an edge. This can describe a flow of material, energy or money.
           However, it can also describe the relation (=concordance) between two nodes.
        
           
    # Matrix/Graph Conventions

    ## `loop` Parameter

    There are two different conventions in 

    If `loops=True`, the elements $a_{ii}$ of the adjacency matrix (eg. technosphere matrix) describe a flow from node $i$ to itself, which indicates _self-consumption_.  
    If `loops=False`, the elements $a_{ij}$ of the adjacency matrix (eg. technical coefficient matrix) indicate the production of the output of node $i$.

    $$
    \mathbf{I} - \mathbf{A}
    $$

    and

    $$
    \mathbf{A}
    $$

    ## `edges` Parameter

    Input-output tables are generally very dense. This means that most of the elements in the adjacency matrix are non-zero.
    A table of ~10'000 sectors can therefore have ~300'000 edges.
    Storing all edges of such a system in a graph can therefore require a lot of memory.

    The `edges` parameter allows to retain edges in the matrix, without the need to add it to the graph.

    See Also
    --------
    [`networkx.MultiDiGraph`](https://networkx.org/documentation/stable/reference/classes/multidigraph.html)

    References
    ----------
    - Heijungs, Reinout, Yi Yang, and Hung-Suck Park.  
    "A or I-A? Unifying the computational structures of process-and IO-based LCA for clarity and consistency."  
    _Journal of Industrial Ecology_
    26.5 (2022): 1824-1836.
    doi:[10.1111/jiec.13323](https://doi.org/10.1111/jiec.13323)
    - Diestel, Reinhard.
    _Graph Theory (6th Edition)_.  Springer, 2025.
    doi:[10.1007/978-3-662-70107-2](https://doi.org/10.1007/978-3-662-70107-2)

    """

    def __init__(
        self,
        graph: nx.MultiDiGraph = None,
        **attr
    ):
        super().__init__(graph, **attr)


    def get_node_by_attributes(
        self,
        dict_conditions: dict,
        data: bool = False,
    ) -> str:
        r"""
        Given a dictionary of node attributes, returns the node (=UUID string)
        that matches all conditions.

        Parameters
        ----------
        conditions: dict
            A dictionary of node attributes to match.  
            
            | keys           | values         |
            |----------------|----------------|
            | node attribute | expected value |

        Example
        --------
        ```python
        >>> G = CustomMultiDiGraph()
        >>> G.add_node('A', name='electricity', product='electricity', amount=1000, location='USA')
        >>> G.add_node('B', name='electricity', product='electricity', amount=2000, location='USA')
        >>> G.get_node_by_attributes({'name': 'electricity', 'product': 'electricity'})
        'A'
        ```

        Raises
        ------
        AttributeError
            If no nodes are found that match the condition.
        AttributeError
            If multiple nodes are found that match the condition.

        Returns
        -------
        str
            The node (=UUID string) that matches the conditions.
        """

        def _condition_met(attrs: dict):
            return all(key in attrs and attrs[key] == value for key, value in dict_conditions.items())

        list_of_nodes = [(node, attrs) for node, attrs in self.nodes(data=True) if _condition_met(attrs)]

        if len(list_of_nodes) == 0:
            raise AttributeError("No nodes found with the given attributes.")
        elif len(list_of_nodes) > 1:
            raise AttributeError("Multiple nodes found with the given attributes. Please refine your attributes.")
        else:
            return list_of_nodes[0] if data else list_of_nodes[0][0]


class GreenGraphMatrixContainer():
    """
    GreenGraph class to manage matrices (technosphere, biosphere, characterization, etc.) generated from the graph.

    Attributes
    ----------
    matrices : dict
        A dictionary to store matrices generated from the graph.  
        Note that each matrix is stored as a [`xarray.DataArray`](https://docs.xarray.dev/en/latest/generated/xarray.DataArray.html#xarray.DataArray) object.
    metadata : dict
        A dictionary to store metadata about the class instance.  
        By default, the metadata dictionary contains:  
        - `created`: Timestamp of class instance creation.  

    Methods
    -------
    lca()
        Computes the life cycle assessment (LCA) of the graph.
    lcia()
        Computes the life cycle impact assessment (LCIA) of the graph.

    See Also
    --------
    [`xarray.DataArray`](https://docs.xarray.dev/en/latest/user-guide/data-structures.html)
    """
    def __init__(self):
        self.matrices = {}
        self.metadata = {
            'created': datetime.now(),
        }


    def lca(
        self,
        demand: dict[str, float],
    ) -> xr.DataArray:
        x = calculate_production_vector(
            A=self.matrices['A'],
            demand=demand
        )
        g = calculate_inventory_vector(
            x=x,
            B=self.matrices['B']
        )
        return g


    def lcia(
        self,
        g: xr.DataArray,
    ) -> xr.DataArray:
        r"""
        Computes the life cycle assessment (LCA) of the graph.

        $$
        \mathbf{h} = \mathbf{Q} \cdot (\mathbf{I} - \mathbf{A})^{-1} \cdot \mathbf{f}
        $$

        Notes
        -----
        This function can be called directly. 
        There is no need to call the [`greengraph.core.GreenGraphMatrixContainer.lca`][] function first.

        Warnings
        --------
        Note that the production vector is computed using the $(\mathbf{I-A})^{-1}$ convention

        References
        ----------
        
        """
        
        h = calculate_impact_vector(
            g=g,
            Q=self.matrices['Q']
        )
        return h