# %%

import numpy as np
import pandas as pd
import xarray as xr
import networkx as nx
from datetime import datetime
import uuid
from operator import itemgetter


from greengraph.math.matrix import (
    calculate_production_vector,
    calculate_inventory_vector,
    calculate_impact_vector
)



class GreenGraphMultiDiGraph(nx.MultiDiGraph):
    r"""
    A custom directed graph class that extends [`networkx.MultiDiGraph`](https://networkx.org/documentation/stable/reference/classes/multidigraph.html).
    

    !!! note "Mathematical Definition"

        A MultiDiGraph is a [**di**rected **graph**](https://en.wikipedia.org/wiki/Directed_graph) that allows **multi**ple edges between nodes:

        ``` mermaid
        graph TD
        1((1)) -->|"(1,2)"₁| 2((2))
        1 -->|"(1,2)₂"| 2
        2 -->|"(2,3)"| 3((3))
        3 -->|"(3,1)"| 1
        ```

    [All NetworkX methods](https://networkx.org/documentation/stable/reference/index.html) of the MultiDiGraph class are available.
    Only the [`add_node`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_node.html#networkx.MultiDiGraph.add_node)
    and [`add_edge`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_edge.html#networkx.MultiDiGraph.add_edge)
    methods have been customized to ensure nodes and edges have consistent attributes:

    # Node Attributes

    | Attribute   | Type   | Description                                                    | Req.? | Possible Values             | 
    |-------------|--------|----------------------------------------------------------------|-------|-----------------------------|
    | uuid        | str    | Unique [random identifier (UUID v4)]((https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random))) | ✅ | Autogenerated |
    | name        | str    | Name of the node (e.g., `electricity production`)              | ✅    | None, can be any string     |
    | product     | str    | Product associated with the node (e.g., 'electricity')         | ✅    | None, can be any string     |
    | amount      | float  | Amount associated with the node (e.g., 1000)                   | ✅    | None, can be any float      |
    | location    | str    | Location of the node (e.g., 'USA')                             | ❌    | None, can be any string     |
    | type        | str    | Type of the node (e.g., `process`, `sector`)                   | ❌    | None, can be any string     |
    | unit        | str    | Unit of the amount (e.g., `GWh`)                               | ❌    | None, can be any string     |
    | loops       | bool   | Whether the node has loops (default: False)                    | ❌    | True, False                 |
    | edges       | bool   | Whether the node has edges (default: False)                    | ❌    | True, False                 |
    | database    | str    | Database associated with the node (e.g., 'Ecoinvent')          | ❌    | None, can be any string     |
    | databasecode| str    | XXXXXXXXXXXXXXXXXXXXXXXXXXX                                    | ❌    | None, can be any string     |
    | metadata    | dict   | Additional metadata for the node (default: empty dict)         | ❌    | None, can be any dictionary |

    # Edge Attributes

    | Attribute   | Type   | Description                                                    | Req.? | Possible Values             |
    |-------------|--------|----------------------------------------------------------------|-------|-----------------------------|
    | uuid        | str    | Unique [random identifier (UUID v4)]((https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random))) | ✅ | Autogenerated |
    | name        | str    | Name of the edge (e.g., `electricity`)              | ❌    | None, can be any string     |
    | weight      | float  | Weight of the edge (e.g., `1000`)                   | ✅    | None, can be any float      |
    | unit        | str    | Unit of the weight (e.g., `GWh`)                               | ❌    | None, can be any string     |
    | databasecode| str    | XXXXXXXXXXXXXXXXXXXXXXXXXXX                                    | ❌    | None, can be any string     |
    | metadata    | dict   | Additional metadata for the edge (default: empty dict)         | ❌    | None, can be any dictionary |

    !!! Terminology

        - `flow` is used in the meaning of Diestel (2025), describing a numerical value assigned to an edge. This can describe a flow of material, energy or money.
           However, it can also describe the relation (=concordance) between two nodes.
        
           
    # Matrix/Graph Conventions

    ## `loop` Parameter

    There are two different conventions in 

    If `loops=True`, the elements $a_{ii}$ of the adjacency matrix (eg. technosphere matrix) describe a flow from node $i$ to itself, which indicates _self-consumption_.  
    If `loops=False`, the elements $a_{ij}$ of the adjacency matrix (eg. technical coefficient matrix) indicate the production of the output of node $i$.

    $$
    \mathbf{I} - \mathbf{A}
    $$

    and

    $$
    \mathbf{A}
    $$

    ## `edges` Parameter

    Input-output tables are generally very dense. This means that most of the elements in the adjacency matrix are non-zero.
    A table of ~10'000 sectors can therefore have ~300'000 edges.
    Storing all edges of such a system in a graph can therefore require a lot of memory.

    The `edges` parameter allows to retain edges in the matrix, without the need to add it to the graph.

    See Also
    --------
    [`networkx.MultiDiGraph`](https://networkx.org/documentation/stable/reference/classes/multidigraph.html)

    References
    ----------
    - Heijungs, Reinout, Yi Yang, and Hung-Suck Park.  
    "A or I-A? Unifying the computational structures of process-and IO-based LCA for clarity and consistency."  
    _Journal of Industrial Ecology_
    26.5 (2022): 1824-1836.
    doi:[10.1111/jiec.13323](https://doi.org/10.1111/jiec.13323)
    - Diestel, Reinhard.
    _Graph Theory (6th Edition)_.  Springer, 2025.
    doi:[10.1007/978-3-662-70107-2](https://doi.org/10.1007/978-3-662-70107-2)

    """,
    def __init__(
        self,
        graph: nx.MultiDiGraph = None,
        **attr
    ) -> None:
        super().__init__(graph, **attr)

    LIST_REQUIRED_NODE_ATTRIBUTES = [
        'type',
    ]
    DICT_REQUIRED_NODE_ATTRIBUTES_BY_TYPE = {
        'production': ['production', 'unit'],
        'extension': ['production', 'unit'],
        'indicator': ['unit'],
    }

    DICT_REQUIRED_EDGE_ATTRIBUTES = {
        'type': {
            'flow': ['amount'],
            'concordance': [],
            'characterization': ['weight']
        }
    }

    def _validate_new_edge_attributes(
        self,
        dict_attr
    ) -> None:
        """
        """
        if dict_attr is None:
            raise ValueError("New edges must be supplied with all required attributes.")
        for attr_toplevel in self.DICT_REQUIRED_EDGE_ATTRIBUTES:
            if attr_toplevel not in dict_attr:
                raise ValueError(f"New edge must be supplied with attribute '{attr_toplevel}'")
            else:
                list_attr_secondlevel = self.DICT_REQUIRED_EDGE_ATTRIBUTES[attr_toplevel][dict_attr[attr_toplevel]]
                if list_attr_secondlevel is None:
                    pass
                else:
                    for attr_secondlevel in list_attr_secondlevel:
                        if attr_secondlevel not in dict_attr:
                            raise ValueError(f"New edge must be supplied with attribute '{attr_secondlevel}'")

    def _validate_new_node_attributes(
        self,
        node,
        dict_attr
    ) -> None:
        """
        Validates that if a node is new, the attributes provided in the current
        call contain all REQUIRED_NODE_ATTRIBUTES.
        This is called before the node is actually added by the superclass method.
        """
        if dict_attr is None:
            raise ValueError(f"New node '{node}' must be supplied with all required attributes.")
        
        list_required_attrs_complete = self.LIST_REQUIRED_NODE_ATTRIBUTES + list(self.DICT_REQUIRED_NODE_ATTRIBUTES_BY_TYPE.get(dict_attr['type'], None))
        if node not in self:
            list_missing_attrs = [
                required_attr for required_attr in list_required_attrs_complete
                if required_attr not in dict_attr
            ]
            if list_missing_attrs:
                raise ValueError(f"New node must be supplied with all required attributes. Missing attributes: {list_missing_attrs}")
        else:
            pass

    

    def add_node(
        self,
        node_for_adding,
        **attr
    ) -> None:
        """
        Adds a single node. 
        If the node is new, attributes provided in `**attr` must include all
        REQUIRED_NODE_ATTRIBUTES.
        If the node already exists, its attributes are updated with `**attr`.
        It's assumed existing nodes already meet requirements for their original
        required attributes, and this update won't be re-checked for that original set.
        """
        self._validate_new_node_attributes(node_for_adding, attr)
        super().add_node(node_for_adding, **attr)
    
    def add_nodes_from(
        self,
        nodes_for_adding,
        **attr
    ) -> None:
        """
        Adds multiple nodes.
        For any node in `nodes_for_adding` that is new to the graph, 
        its attributes (from tuple or global **attr) must include all
        REQUIRED_NODE_ATTRIBUTES.
        If a node already exists, its attributes are updated. It's assumed
        existing nodes already meet requirements.
        """
        dict_all_attributes = {}
        dict_all_attributes.update(attr)
        for node_entry in nodes_for_adding:
            """
            nodes_for_adding can be a list of tuples,
            where the first element is the node
            and the second element is a dictionary of attributes:

            [
                (
                    node_id,
                    {attr1: value1, attr2: value2}
                ),
            ]

            nodes_for_adding can also be a list-like object of nodes, 
            with attributes that are the same for all these nodes
            passed in the global **attr:

            [
                node_id,
                node_id,
                ...
            ]
            """
            if (
                isinstance(node_entry, tuple) and
                isinstance(node_entry[1], dict)
            ):
                dict_all_attributes.update(node_entry[1])
                self._validate_new_node_attributes(
                    node=node_entry[0],
                    dict_attr=dict_all_attributes
                )
            else:
                self._validate_new_node_attributes(
                    node=node_entry,
                    dict_attr=dict_all_attributes
                )

        super().add_nodes_from(nodes_for_adding, **attr)


    
    def add_edge(
        self,
        u_for_edge,
        v_for_edge,
        key,
        dict_attr,
        **attr
    ) -> None:
        """
        Warnings
        --------
        This method accepts a dictionary of edge attributes `dict_attr`
        that will be added to the edge attributes.
        The [`networkx.MultiDiGraph.add_edge`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_edge.html#networkx.MultiDiGraph.add_edge)
        method does not accept this parameter.

        Notes
        -----
        Attributes in `dict_attr` take precedence (=overwrite)
        those passed as keywords `**attr`.

        See Also
        --------
        [`networkx.MultiDiGraph.add_edge`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_edge.html#networkx.MultiDiGraph.add_edge)
        """
        dict_attr_combined = {**attr, **(dict_attr or {})}
        self._validate_new_edge_attributes(dict_attr=dict_attr_combined)
        key = super().add_edge(u_for_edge, v_for_edge, key)
        self[u_for_edge][v_for_edge][key].update(dict_attr_combined)
        return key
    
    def add_edges_from(self, ebunch_to_add, **attr) -> None:
        """
        Warnings
        --------
        Beware of bananas.

        See Also
        --------
        [`networkx.MultiDiGraph.add_edges_from`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_edges_from.html#networkx.MultiDiGraph.add_edges_from)
        """
        list_keys = []
        for e in ebunch_to_add:
            if len(e) == 2:
                u, v = e
                dict_attr = None
                key = None
            elif len(e) == 3:
                u, v, third = e
                if isinstance(third, dict):
                    dict_attr = third
                    key = None
                else:
                    dict_attr = None
                    key = third
            elif len(e) == 4:
                u, v, key, dict_attr = e
            else:
                raise nx.NetworkXError(f"Edge tuple {e} must be a 2-tuple, 3-tuple or 4-tuple.")
            key = self.add_edge(u, v, dict_attr=dict_attr, key=key, **attr)
            list_keys.append(key)
        nx._clear_cache(self)
        return list_keys


    def get_node_by_attributes(
        self,
        dict_conditions: dict,
        data: bool = False,
    ) -> str:
        r"""
        Given a dictionary of node attributes, returns the node (=UUID string)
        that matches all conditions.

        Parameters
        ----------
        conditions: dict
            A dictionary of node attributes to match.  
            
            | keys           | values         |
            |----------------|----------------|
            | node attribute | expected value |

        Notes
        -----
        This is a utility function. Nodes can also be filtered using a list comprehension:
        ```python
        [node for node, attrs in G.nodes(data=True) if all(key in attrs and attrs[key] == value for key, value in dict_conditions.items())]
        ```    

        Example
        --------
        ```python
        >>> G = CustomMultiDiGraph()
        >>> G.add_node('A', name='electricity', product='electricity', amount=1000, location='USA')
        >>> G.add_node('B', name='electricity', product='electricity', amount=2000, location='USA')
        >>> G.get_node_by_attributes({'name': 'electricity', 'product': 'electricity'})
        'A'
        ```

        Raises
        ------
        AttributeError
            If no nodes are found that match the condition.
        AttributeError
            If multiple nodes are found that match the condition.

        Returns
        -------
        str
            The node (=UUID string) that matches the conditions.
        """

        def _condition_met(attrs: dict):
            return all(key in attrs and attrs[key] == value for key, value in dict_conditions.items())

        list_of_nodes = [(node, attrs) for node, attrs in self.nodes(data=True) if _condition_met(attrs)]

        if len(list_of_nodes) == 0:
            raise AttributeError("No nodes found with the given attributes.")
        elif len(list_of_nodes) > 1:
            raise AttributeError("Multiple nodes found with the given attributes. Please refine your attributes.")
        else:
            return list_of_nodes[0] if data else list_of_nodes[0][0]
        

    


class GreenGraphMatrixContainer():
    """
    GreenGraph class to manage matrices (technosphere, biosphere, characterization, etc.) generated from the graph.

    Attributes
    ----------
    matrices : dict
        A dictionary to store matrices generated from the graph.  
        Note that each matrix is stored as a [`xarray.DataArray`](https://docs.xarray.dev/en/latest/generated/xarray.DataArray.html#xarray.DataArray) object.
    metadata : dict
        A dictionary to store metadata about the class instance.  
        By default, the metadata dictionary contains:  
        - `created`: Timestamp of class instance creation.  

    Methods
    -------
    lca()
        Computes the life cycle assessment (LCA) of the graph.
    lcia()
        Computes the life cycle impact assessment (LCIA) of the graph.

    See Also
    --------
    [`xarray.DataArray`](https://docs.xarray.dev/en/latest/user-guide/data-structures.html)
    """
    def __init__(self):
        self.matrices = {}
        self.metadata = {
            'created': datetime.now(),
        }


    def lca(
        self,
        demand: dict[str, float],
    ) -> xr.DataArray:
        x = calculate_production_vector(
            A=self.matrices['A'],
            demand=demand
        )
        g = calculate_inventory_vector(
            x=x,
            B=self.matrices['B']
        )
        return g


    def lcia(
        self,
        g: xr.DataArray,
    ) -> xr.DataArray:
        r"""
        Computes the life cycle assessment (LCA) of the graph.

        $$
        \mathbf{h} = \mathbf{Q} \cdot (\mathbf{I} - \mathbf{A})^{-1} \cdot \mathbf{f}
        $$

        Notes
        -----
        This function can be called directly. 
        There is no need to call the [`greengraph.core.GreenGraphMatrixContainer.lca`][] function first.

        Warnings
        --------
        Note that the production vector is computed using the $(\mathbf{I-A})^{-1}$ convention

        References
        ----------
        
        """
        
        h = calculate_impact_vector(
            g=g,
            Q=self.matrices['Q']
        )
        return h