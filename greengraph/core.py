# %%
r"""
This module contains the classes containing the graph and matrix representations of the supply chain data.
"""

from datetime import datetime
import networkx as nx
import xarray as xr
import importlib.metadata

from greengraph.math.matrix import (
    calculate_production_vector,
    calculate_inventory_vector,
    calculate_impact_vector
)

class GreenMultiDiGraph(nx.MultiDiGraph):
    r"""
    A custom directed graph class that extends [`networkx.MultiDiGraph`](https://networkx.org/documentation/stable/reference/classes/multidigraph.html).
    All methods of this parent class are available. Some methods are customized to ensure that nodes and edges have consistent attributes.

    !!! note "Mathematical Definition"

        A MultiDiGraph is a [**di**rected **graph**](https://en.wikipedia.org/wiki/Directed_graph) that allows **multi**ple edges between nodes:

        ``` mermaid
        graph TD
        1((1)) -->|"(1,2)"₁| 2((2))
        1 -->|"(1,2)₂"| 2
        2 -->|"(2,3)"| 3((3))
        3 -->|"(3,1)"| 1
        ```
    
    Warnings
    --------
    The `GreenMultiDiGraph` requires that every node and every edge have a set of attributes.

    ```python
    GreenMultiDiGraph.list_required_node_attributes()
    ```

    **Production Nodes** (`type='production'`)

    | Attribute    | Type   | Description                                                    |
    |--------------|--------|----------------------------------------------------------------|
    | `production` | float  | Production associated with the node (e.g., `1000`)             |
    | `unit`       | str    | Unit of the production (e.g., `kg`)                            |

    **Extension Nodes** (`type='extension'`)

    | Attribute    | Type   | Description                                                    |
    |--------------|--------|----------------------------------------------------------------|
    | `production` | float  | Production associated with the node (e.g., `1000`)             |
    | `unit`       | str    | Unit of the production (e.g., `kg(CO₂)`)                       |

    **Indicator Nodes** (`type='indicator'`)

    | Attribute   | Type   | Description                                                    |
    |-------------|--------|----------------------------------------------------------------|
    | `unit`      | str    | Unit of the indicator (e.g., `°C`)                             |

    Of course, it is possible to add other attributes to the nodes, but these are not required.
    Some other useful attributes, in the context of life-cycle assessment and
    supply chain analysis, are:

    | Attribute   | Type   | Description                                                    |
    |-------------|--------|----------------------------------------------------------------|
    | uuid        | str    | Unique [random identifier]((https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random))) |
    | name        | str    | Name of the node (e.g., `electricity production`)              |
    | product     | str    | Product associated with the node (e.g., `electricity`)         |
    | location    | str    | Location of the node (e.g., 'USA')                             |
    | database    | str    | Database associated with the node (e.g., `Ecoinvent`)          |
    | code        | str    | The original identifier of the node in the database            |
    | metadata    | dict   | Additional metadata for the node                               |

    # Edge Attributes

    | Attribute   | Type   | Description                                                    | Req.? | Possible Values             |
    |-------------|--------|----------------------------------------------------------------|-------|-----------------------------|
    | uuid        | str    | Unique [random identifier (UUID v4)]((https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random))) | ✅ | Autogenerated |
    | name        | str    | Name of the edge (e.g., `electricity`)              | ❌    | None, can be any string     |
    | weight      | float  | Weight of the edge (e.g., `1000`)                   | ✅    | None, can be any float      |
    | unit        | str    | Unit of the weight (e.g., `GWh`)                               | ❌    | None, can be any string     |
    | databasecode| str    | XXXXXXXXXXXXXXXXXXXXXXXXXXX                                    | ❌    | None, can be any string     |
    | metadata    | dict   | Additional metadata for the edge (default: empty dict)         | ❌    | None, can be any dictionary |

    !!! Terminology

        - `flow` is used in the meaning of Diestel (2025), describing a numerical value assigned to an edge. This can describe a flow of material, energy or money.
           However, it can also describe the relation (=concordance) between two nodes.
        
           
    # Matrix/Graph Conventions

    ## `loop` Parameter

    There are two different conventions in 

    If `loops=True`, the elements $a_{ii}$ of the adjacency matrix (eg. technosphere matrix) describe a flow from node $i$ to itself, which indicates _self-consumption_.  
    If `loops=False`, the elements $a_{ij}$ of the adjacency matrix (eg. technical coefficient matrix) indicate the production of the output of node $i$.

    $$
    \mathbf{I} - \mathbf{A}
    $$

    and

    $$
    \mathbf{A}
    $$

    ## `edges` Parameter

    Input-output tables are generally very dense. This means that most of the elements in the adjacency matrix are non-zero.
    A table of ~10'000 sectors can therefore have ~300'000 edges.
    Storing all edges of such a system in a graph can therefore require a lot of memory.

    The `edges` parameter allows to retain edges in the matrix, without the need to add it to the graph.

    See Also
    --------
    [`networkx.MultiDiGraph`](https://networkx.org/documentation/stable/reference/classes/multidigraph.html)

    References
    ----------
    - Heijungs, Reinout, Yi Yang, and Hung-Suck Park.  
    "A or I-A? Unifying the computational structures of process-and IO-based LCA for clarity and consistency."  
    _Journal of Industrial Ecology_
    26.5 (2022): 1824-1836.
    doi:[10.1111/jiec.13323](https://doi.org/10.1111/jiec.13323)
    - Diestel, Reinhard.
    _Graph Theory (6th Edition)_.  Springer, 2025.
    doi:[10.1007/978-3-662-70107-2](https://doi.org/10.1007/978-3-662-70107-2)

    """
    def __init__(
        self,
        graph: nx.MultiDiGraph = None,
        **attr
    ) -> None:
        r"""
        https://networkx.org/documentation/stable/tutorial.html#adding-attributes-to-graphs-nodes-and-edges
        """
        super().__init__(graph, **attr)
        self.graph['greengraph'] = importlib.metadata.version('greengraph')
    
    def _validate_node_attributes(
        self,
        node,
        dict_attr,
    ) -> None:
        r"""
        """

        dict_required_attributes = {
            'production': {'production', 'unit'},
            'extension': {'production', 'unit'},
            'indicator': {'unit'},
        }

        if node is not None and node in self:
            return
        if dict_attr is None:
            raise ValueError(f"Node must be supplied with required attributes. No attributes were provided.")
        
        if 'type' not in dict_attr:
            raise ValueError("Node must have a 'type' attribute. No type was provided.")
        
        node_type = dict_attr['type']

        if node_type not in dict_required_attributes.keys():
            valid_types = "', '".join(dict_required_attributes.keys())
            raise ValueError(f"Invalid node type: '{node_type}'. Valid types are: '{valid_types}'.")

        set_required_attributes = dict_required_attributes[node_type]
        set_provided_attributes = set(dict_attr.keys())
        set_missing_attributes = set_required_attributes - set_provided_attributes

        if set_missing_attributes:
            raise ValueError(f"Node is missing required attributes: {set_missing_attributes}.")
        
    def _validate_edge_attributes(
        self,
        dict_attr
    ) -> None:
        r"""
        """

        dict_required_attributes = {
            'flow': {'weight', 'unit'},
            'concordance': {},
            'characterization': {'weight', 'unit'},
        }

        if dict_attr is None:
            raise ValueError(f"Edge must be supplied with required attributes. No attributes were provided.")
        
        if 'type' not in dict_required_attributes:
            raise ValueError("Edge must have a 'type' attribute. No type was provided.")
        
        edge_type = dict_attr['type']

        if edge_type not in dict_required_attributes.keys():
            valid_types = "', '".join(dict_required_attributes.keys())
            raise ValueError(f"Invalid edge type: '{edge_type}'. Valid types are: '{valid_types}'.")

        set_required_attributes = dict_required_attributes[edge_type]
        set_provided_attributes = set(dict_attr.keys())
        set_missing_attributes = set_required_attributes - set_provided_attributes

        if set_missing_attributes:
            raise ValueError(f"Node is missing required attributes: {set_missing_attributes}.")


    def add_node(
        self,
        node_for_adding,
        **attr
    ) -> None:
        """
        """
        self._validate_new_node_attributes(node_for_adding, attr)
        super().add_node(node_for_adding, **attr)
    
    def add_nodes_from(
        self,
        nodes_for_adding,
        **attr
    ) -> None:
        """
        """
        dict_all_attributes = {}
        dict_all_attributes.update(attr)
        for node_entry in nodes_for_adding:
            """
            nodes_for_adding can be a list of tuples,
            where the first element is the node
            and the second element is a dictionary of attributes:

            [
                (
                    node_id,
                    {attr1: value1, attr2: value2}
                ),
            ]

            nodes_for_adding can also be a list-like object of nodes, 
            with attributes that are the same for all these nodes
            passed in the global **attr:

            [
                node_id,
                node_id,
                ...
            ]
            """
            if (
                isinstance(node_entry, tuple) and
                isinstance(node_entry[1], dict)
            ):
                dict_all_attributes.update(node_entry[1])
                self._validate_new_node_attributes(
                    node=node_entry[0],
                    dict_attr=dict_all_attributes
                )
            else:
                self._validate_new_node_attributes(
                    node=node_entry,
                    dict_attr=dict_all_attributes
                )

        super().add_nodes_from(nodes_for_adding, **attr)


    
    def add_edge(
        self,
        u_for_edge,
        v_for_edge,
        key,
        dict_attr,
        **attr
    ) -> None:
        """
        Warnings
        --------
        This method accepts a dictionary of edge attributes `dict_attr`
        that will be added to the edge attributes.  
        The [`networkx.MultiDiGraph.add_edge`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_edge.html#networkx.MultiDiGraph.add_edge)
        method does not accept this parameter.

        Notes
        -----
        Attributes in `dict_attr` take precedence over (=overwrite)
        those passed as keywords `**attr`.

        See Also
        --------
        [`networkx.MultiDiGraph.add_edge`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_edge.html#networkx.MultiDiGraph.add_edge)
        """
        dict_attr_combined = {**attr, **(dict_attr or {})}
        self._validate_new_edge_attributes(dict_attr=dict_attr_combined)
        key = super().add_edge(u_for_edge, v_for_edge, key)
        self[u_for_edge][v_for_edge][key].update(dict_attr_combined)
        return key
    
    def add_edges_from(self, ebunch_to_add, **attr) -> None:
        """
        Warnings
        --------
        Beware of bananas.

        See Also
        --------
        [`networkx.MultiDiGraph.add_edges_from`](https://networkx.org/documentation/stable/reference/classes/generated/networkx.MultiDiGraph.add_edges_from.html#networkx.MultiDiGraph.add_edges_from)
        """
        list_keys = []
        for e in ebunch_to_add:
            if len(e) == 2:
                u, v = e
                dict_attr = None
                key = None
            elif len(e) == 3:
                u, v, third = e
                if isinstance(third, dict):
                    dict_attr = third
                    key = None
                else:
                    dict_attr = None
                    key = third
            elif len(e) == 4:
                u, v, key, dict_attr = e
            else:
                raise nx.NetworkXError(f"Edge tuple {e} must be a 2-tuple, 3-tuple or 4-tuple.")
            key = self.add_edge(u, v, dict_attr=dict_attr, key=key, **attr)
            list_keys.append(key)
        nx._clear_cache(self)
        return list_keys


    def get_node_by_attributes(
        self,
        dict_conditions: dict,
        data: bool = False,
    ) -> str:
        r"""
        Given a dictionary of node attributes, returns the node (=UUID string)
        that matches all conditions.

        Parameters
        ----------
        conditions: dict
            A dictionary of node attributes to match.  
            
            | keys           | values         |
            |----------------|----------------|
            | node attribute | expected value |

        Notes
        -----
        This is a utility function. Nodes can also be filtered using a list comprehension:
        ```python
        [node for node, attrs in G.nodes(data=True) if all(key in attrs and attrs[key] == value for key, value in dict_conditions.items())]
        ```    

        Example
        --------
        ```python
        >>> G = CustomMultiDiGraph()
        >>> G.add_node('A', name='electricity', product='electricity', amount=1000, location='USA')
        >>> G.add_node('B', name='electricity', product='electricity', amount=2000, location='USA')
        >>> G.get_node_by_attributes({'name': 'electricity', 'product': 'electricity'})
        'A'
        ```

        Raises
        ------
        AttributeError
            If no nodes are found that match the condition.
        AttributeError
            If multiple nodes are found that match the condition.

        Returns
        -------
        str
            The node (=UUID string) that matches the conditions.
        """

        def _condition_met(attrs: dict):
            return all(key in attrs and attrs[key] == value for key, value in dict_conditions.items())

        list_of_nodes = [(node, attrs) for node, attrs in self.nodes(data=True) if _condition_met(attrs)]

        if len(list_of_nodes) == 0:
            raise AttributeError("No nodes found with the given attributes.")
        elif len(list_of_nodes) > 1:
            raise AttributeError("Multiple nodes found with the given attributes. Please refine your attributes.")
        else:
            return list_of_nodes[0] if data else list_of_nodes[0][0]
        
    def get_random_node(
        self,
        type: str = None,
        data: bool = False,
    ) -> str:
        r"""
        Returns a random node from the graph.

        Parameters
        ----------
        type : str, optional
            The type of node to return. If `None`, any node is returned.
        data : bool, optional
            If `True`, returns the node and its attributes. If `False`, returns only the node.

        Returns
        -------
        str
            The node (=UUID string) that matches the conditions.
        """
        if type is not None:
            list_nodes = [node for node, attrs in self.nodes(data=True) if attrs['type'] == type]
            if len(list_nodes) == 0:
                raise AttributeError(f"No nodes found with the given type '{type}'.")
            return random.choice(list_nodes)
        
        return random.choice(list(self.nodes()))
    


class GreenGraphMatrixContainer():
    """
    GreenGraph class to manage matrices (technosphere, biosphere, characterization, etc.) generated from the graph.

    Attributes
    ----------
    matrices : dict
        A dictionary to store matrices generated from the graph.  
        Note that each matrix is stored as a [`xarray.DataArray`](https://docs.xarray.dev/en/latest/generated/xarray.DataArray.html#xarray.DataArray) object.
    metadata : dict
        A dictionary to store metadata about the class instance.  
        By default, the metadata dictionary contains:  
        - `created`: Timestamp of class instance creation.  

    Methods
    -------
    lca()
        Computes the life cycle assessment (LCA) of the graph.
    lcia()
        Computes the life cycle impact assessment (LCIA) of the graph.

    See Also
    --------
    [`xarray.DataArray`](https://docs.xarray.dev/en/latest/user-guide/data-structures.html)
    """
    def __init__(self):
        self.matrices = {}
        self.metadata = {
            'created': datetime.now(),
        }


    def lca(
        self,
        demand: dict[str, float],
    ) -> xr.DataArray:
        x = calculate_production_vector(
            A=self.matrices['A'],
            demand=demand
        )
        g = calculate_inventory_vector(
            x=x,
            B=self.matrices['B']
        )
        return g


    def lcia(
        self,
        g: xr.DataArray,
    ) -> xr.DataArray:
        r"""
        Computes the life cycle assessment (LCA) of the graph.

        $$
        \mathbf{h} = \mathbf{Q} \cdot (\mathbf{I} - \mathbf{A})^{-1} \cdot \mathbf{f}
        $$

        Notes
        -----
        This function can be called directly. 
        There is no need to call the [`greengraph.core.GreenGraphMatrixContainer.lca`][] function first.

        Warnings
        --------
        Note that the production vector is computed using the $(\mathbf{I-A})^{-1}$ convention

        References
        ----------
        
        """
        
        h = calculate_impact_vector(
            g=g,
            Q=self.matrices['Q']
        )
        return h